#!/bin/sh
[ "$ACTION" = add ] || exit

NPROCS="$(grep -c "^processor.*:" /proc/cpuinfo)"
[ "$NPROCS" -gt 1 ] || exit

PROC_MASK="$(( (1 << $NPROCS) - 1 ))"

find_irq_cpu() {
	local dev="$1"
	local match="$(grep -m 1 "$dev\$" /proc/interrupts)"
	local cpu=0

	[ -n "$match" ] && {
		set -- $match
		shift
		for cur in `seq 1 $NPROCS`; do
			[ "$1" -gt 0 ] && {
				cpu=$(($cur - 1))
				break
			}
			shift
		done
	}

	echo "$cpu"
}

set_hex_val() {
	local file="$1"
	local val="$2"
	val="$(printf %x "$val")"
	[ -n "$DEBUG" ] && echo "$file = $val"
	echo "$val" > "$file"
}

packet_steering="$(uci get "network.@globals[0].packet_steering")"
[ "$packet_steering" != 1 ] && exit 0

exec 512>/var/lock/smp_tune.lock
flock 512 || exit 1

for dev in /sys/class/net/*; do
	[ -d "$dev" ] || continue

	# ignore virtual interfaces
	[ -n "$(ls "${dev}/" | grep '^lower_')" ] && continue
	[ -d "${dev}/device" ] || continue

	device="$(readlink "${dev}/device")"
	device="$(basename "$device")"
	irq_cpu="$(find_irq_cpu "$device")"
	irq_cpu_mask="$((1 << $irq_cpu))"

	for q in ${dev}/queues/rx-*; do
		set_hex_val "$q/rps_cpus" "$(($PROC_MASK & ~$irq_cpu_mask))"
	done

	ntxq="$(ls -d ${dev}/queues/tx-* | wc -l)"

	idx=$(($irq_cpu + 1))
	for q in ${dev}/queues/tx-*; do
		set_hex_val "$q/xps_cpus" "$((1 << $idx))"
		let "idx = idx + 1"
		[ "$idx" -ge "$NPROCS" ] && idx=0
	done
	
INTERRUPT=$(ls /proc/irq/ | sed '/default/d')
USB3_NUMBER=$(grep usb2 /proc/interrupts | awk -F: '{print $1}' | sed 's/^ //')

for i in ${INTERRUPT}; do
	if [[ $i = ${USB2_NUMBER} ]]; then
        	echo f > /proc/irq/$i/smp_affinity 2>/dev/null
        else
        	echo e > /proc/irq/$i/smp_affinity 2>/dev/null
        fi
done
	
IFACE=$(ls /sys/class/net)

for i in ${IFACE}; do
	ethtool -K $i gro on 2>/dev/null
	if [[ -e /sys/class/net/$i/queues/rx-0/rps_cpus ]]; then
		if [[ $i = "wwan0_1" ]]; then
			echo f > /sys/class/net/$i/queues/rx-0/rps_cpus
		else
			echo f > /sys/class/net/$i/queues/rx-0/rps_cpus
		fi
	fi
done
